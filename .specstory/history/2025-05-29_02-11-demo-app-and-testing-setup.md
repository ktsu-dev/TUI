<!-- Generated by SpecStory -->

# Demo App and Testing Setup (2025-05-29 12:11:52)

_**User**_

create a demo app and tests

---

_**Assistant**_



---

I'll help you create a demo app and tests for your TUI project. Let me first explore the existing codebase to understand the structure and functionality.

---

Read file: TUI.sln

---

Now let me explore the core library to understand what TUI components are available:

---

<details>
            <summary>Listed directory TUI.Core • **8** results</summary>
        
| Name |
|-------|
| 📄 `TUI.Core.csproj` |
| 📁 `Extensions` |
| 📁 `Services` |
| 📁 `Elements` |
| 📁 `Models` |
| 📁 `Contracts` |
| 📁 `obj` |
| 📁 `bin` |

</details>

---

Read file: TUI.Core/TUI.Core.csproj

---

<details>
            <summary>Listed directory TUI.Core/Elements • **4** results</summary>
        
| Name |
|-------|
| 📁 `Layouts` |
| 📁 `Primitives` |
| 📄 `UIContainerBase.cs` |
| 📄 `UIElementBase.cs` |

</details>

---

<details>
            <summary>Listed directory TUI.Core/Elements/Primitives • **2** results</summary>
        
| Name |
|-------|
| 📄 `BorderElement.cs` |
| 📄 `TextElement.cs` |

</details>

---

<details>
            <summary>Listed directory TUI.Core/Elements/Layouts • **1** results</summary>
        
| Name |
|-------|
| 📄 `StackPanel.cs` |

</details>

---

Read file: TUI.Core/Elements/UIElementBase.cs

---

Read file: TUI.Core/Elements/Primitives/TextElement.cs

---

Could not find file 'TUI.Core/Models' in the workspace.

---

<details>
            <summary>Listed directory TUI.Core/Models • **5** results</summary>
        
| Name |
|-------|
| 📄 `InputResult.cs` |
| 📄 `TextStyle.cs` |
| 📄 `Padding.cs` |
| 📄 `Dimensions.cs` |
| 📄 `Position.cs` |

</details>

---

<details>
            <summary>Listed directory TUI.Core/Services • **2** results</summary>
        
| Name |
|-------|
| 📄 `UIApplication.cs` |
| 📄 `SpectreConsoleProvider.cs` |

</details>

---

Read file: TUI.App/TUI.App.csproj

---

<details>
            <summary>Listed directory TUI.App • **4** results</summary>
        
| Name |
|-------|
| 📄 `TUI.App.csproj` |
| 📄 `SampleApp.cs` |
| 📁 `obj` |
| 📁 `bin` |

</details>

---

Read file: TUI.App/SampleApp.cs

---

<details>
            <summary>Listed directory TUI.Test • **4** results</summary>
        
| Name |
|-------|
| 📄 `TUI.Test.csproj` |
| 📁 `obj` |
| 📄 `SampleTests.cs` |
| 📁 `bin` |

</details>

---

Read file: TUI.Test/TUI.Test.csproj

---

Read file: TUI.Test/SampleTests.cs

---

Now I understand the TUI library structure. It's a Terminal User Interface library built on top of Spectre.Console with:

- **Elements**: Base UI components (TextElement, BorderElement)
- **Layouts**: Container components (StackPanel)
- **Models**: Data structures (Position, Dimensions, TextStyle, etc.)
- **Services**: Core application services (UIApplication, SpectreConsoleProvider)

Let me create a comprehensive demo app and test suite. First, I'll create an enhanced demo app:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.TUI.App;
+ 
+ /// <summary>
+ /// Entry point for the TUI Demo Application
+ /// </summary>
+ internal static class Program
+ {
+ 	/// <summary>
+ 	/// Main entry point
+ 	/// </summary>
+ 	/// <param name="args">Command line arguments</param>
+ 	/// <returns>Exit code</returns>
+ 	public static async Task<int> Main(string[] args)
+ 	{
+ 		try
+ 		{
+ 			// Check for command line arguments
+ 			if (args.Length > 0 && args[0] == "--interactive")
+ 			{
+ 				await InteractiveDemo.RunAsync();
+ 			}
+ 			else if (args.Length > 0 && args[0] == "--showcase")
+ 			{
+ 				await ShowcaseDemo.RunAsync();
+ 			}
+ 			else
+ 			{
+ 				await SampleApp.Main();
+ 			}
+ 
+ 			return 0;
+ 		}
+ 		catch (Exception ex)
+ 		{
+ 			Console.Error.WriteLine($"Error: {ex.Message}");
+ 			return 1;
+ 		}
+ 	}
+ } 
```

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.TUI.Core.Contracts;
+ using ktsu.TUI.Core.Elements.Layouts;
+ using ktsu.TUI.Core.Elements.Primitives;
+ using ktsu.TUI.Core.Models;
+ using ktsu.TUI.Core.Services;
+ 
+ namespace ktsu.TUI.App;
+ 
+ /// <summary>
+ /// Interactive demo showcasing user input and dynamic updates
+ /// </summary>
+ public static class InteractiveDemo
+ {
+ 	private static TextElement? _statusText;
+ 	private static TextElement? _counterText;
+ 	private static BorderElement? _inputPanel;
+ 	private static int _counter = 0;
+ 
+ 	/// <summary>
+ 	/// Runs the interactive demo
+ 	/// </summary>
+ 	public static async Task RunAsync()
+ 	{
+ 		var consoleProvider = new SpectreConsoleProvider();
+ 		var app = UIApplication.CreateBuilder(consoleProvider)
+ 			.UseRootElement(CreateInteractiveUI())
+ 			.Build();
+ 
+ 		Console.WriteLine("Starting TUI Interactive Demo. Use the controls shown on screen!");
+ 		await app.RunAsync();
+ 		Console.WriteLine("Interactive Demo finished.");
+ 	}
+ 
+ 	private static IUIElement CreateInteractiveUI()
+ 	{
+ 		var mainLayout = new StackPanel
+ 		{
+ 			Orientation = Orientation.Vertical,
+ 			Spacing = 1,
+ 			Padding = Padding.Uniform(2)
+ 		};
+ 
+ 		// Header
+ 		var header = new BorderElement
+ 		{
+ 			Title = "Interactive TUI Demo",
+ 			TitleAlignment = HorizontalAlignment.Center,
+ 			BorderStyle = BorderStyle.Double,
+ 			Child = new TextElement
+ 			{
+ 				Text = "Real-time UI Updates & Input Handling",
+ 				HorizontalAlignment = HorizontalAlignment.Center,
+ 				Style = new TextStyle { IsBold = true, Foreground = "yellow" }
+ 			}
+ 		};
+ 
+ 		// Status panel
+ 		var statusPanel = CreateStatusPanel();
+ 
+ 		// Counter panel
+ 		var counterPanel = CreateCounterPanel();
+ 
+ 		// Input instructions
+ 		var instructionsPanel = CreateInstructionsPanel();
+ 
+ 		mainLayout.AddChild(header);
+ 		mainLayout.AddChild(statusPanel);
+ 		mainLayout.AddChild(counterPanel);
+ 		mainLayout.AddChild(instructionsPanel);
+ 
+ 		return mainLayout;
+ 	}
+ 
+ 	private static IUIElement CreateStatusPanel()
+ 	{
+ 		_statusText = new TextElement
+ 		{
+ 			Text = "Ready - Waiting for input...",
+ 			Style = new TextStyle { Foreground = "green" },
+ 			HorizontalAlignment = HorizontalAlignment.Center
+ 		};
+ 
+ 		return new BorderElement
+ 		{
+ 			Title = "Status",
+ 			BorderStyle = BorderStyle.Single,
+ 			Child = _statusText
+ 		};
+ 	}
+ 
+ 	private static IUIElement CreateCounterPanel()
+ 	{
+ 		var counterLayout = new StackPanel
+ 		{
+ 			Orientation = Orientation.Horizontal,
+ 			Spacing = 2
+ 		};
+ 
+ 		_counterText = new TextElement
+ 		{
+ 			Text = "0",
+ 			Style = new TextStyle { IsBold = true, Foreground = "cyan" },
+ 			HorizontalAlignment = HorizontalAlignment.Center
+ 		};
+ 
+ 		var counterLabel = new TextElement
+ 		{
+ 			Text = "Counter:",
+ 			Style = new TextStyle { Foreground = "white" }
+ 		};
+ 
+ 		var resetButton = new TextElement
+ 		{
+ 			Text = "[R] Reset",
+ 			Style = new TextStyle { Foreground = "red" }
+ 		};
+ 
+ 		counterLayout.AddChild(counterLabel);
+ 		counterLayout.AddChild(_counterText);
+ 		counterLayout.AddChild(resetButton);
+ 
+ 		return new BorderElement
+ 		{
+ 			Title = "Interactive Counter",
+ 			BorderStyle = BorderStyle.Rounded,
+ 			Child = counterLayout
+ 		};
+ 	}
+ 
+ 	private static IUIElement CreateInstructionsPanel()
+ 	{
+ 		var instructionsText = new TextElement
+ 		{
+ 			Text = "CONTROLS:\n" +
+ 			       "↑/↓  - Increment/Decrement Counter\n" +
+ 			       "SPACE - Add +10 to Counter\n" +
+ 			       "R     - Reset Counter\n" +
+ 			       "T     - Toggle Theme\n" +
+ 			       "ESC   - Exit Demo\n\n" +
+ 			       "Watch the status and counter update in real-time!",
+ 			Style = new TextStyle { Foreground = "magenta" }
+ 		};
+ 
+ 		return new BorderElement
+ 		{
+ 			Title = "Instructions",
+ 			BorderStyle = BorderStyle.Thick,
+ 			Child = instructionsText
+ 		};
+ 	}
+ 
+ 	/// <summary>
+ 	/// Simulates input handling (this would be connected to actual input in a full implementation)
+ 	/// </summary>
+ 	/// <param name="key">The key that was pressed</param>
+ 	public static void HandleInput(string key)
+ 	{
+ 		switch (key.ToUpperInvariant())
+ 		{
+ 			case "UP":
+ 				_counter++;
+ 				UpdateCounter();
+ 				UpdateStatus("Counter incremented!");
+ 				break;
+ 
+ 			case "DOWN":
+ 				_counter--;
+ 				UpdateCounter();
+ 				UpdateStatus("Counter decremented!");
+ 				break;
+ 
+ 			case " ":
+ 			case "SPACE":
+ 				_counter += 10;
+ 				UpdateCounter();
+ 				UpdateStatus("Added +10 to counter!");
+ 				break;
+ 
+ 			case "R":
+ 				_counter = 0;
+ 				UpdateCounter();
+ 				UpdateStatus("Counter reset to 0!");
+ 				break;
+ 
+ 			case "T":
+ 				ToggleTheme();
+ 				UpdateStatus("Theme toggled!");
+ 				break;
+ 
+ 			default:
+ 				UpdateStatus($"Unknown key: {key}");
+ 				break;
+ 		}
+ 	}
+ 
+ 	private static void UpdateCounter()
+ 	{
+ 		if (_counterText != null)
+ 		{
+ 			_counterText.Text = _counter.ToString();
+ 		}
+ 	}
+ 
+ 	private static void UpdateStatus(string message)
+ 	{
+ 		if (_statusText != null)
+ 		{
+ 			_statusText.Text = $"{DateTime.Now:HH:mm:ss} - {message}";
+ 		}
+ 	}
+ 
+ 	private static void ToggleTheme()
+ 	{
+ 		if (_counterText != null)
+ 		{
+ 			var currentStyle = _counterText.Style;
+ 			_counterText.Style = new TextStyle
+ 			{
+ 				IsBold = currentStyle.IsBold,
+ 				Foreground = currentStyle.Foreground == "cyan" ? "yellow" : "cyan"
+ 			};
+ 		}
+ 	}
+ } 
```

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.TUI.Core.Contracts;
+ using ktsu.TUI.Core.Elements.Layouts;
+ using ktsu.TUI.Core.Elements.Primitives;
+ using ktsu.TUI.Core.Models;
+ using ktsu.TUI.Core.Services;
+ 
+ namespace ktsu.TUI.App;
+ 
+ /// <summary>
+ /// Comprehensive showcase of all TUI library visual features
+ /// </summary>
+ public static class ShowcaseDemo
+ {
+ 	/// <summary>
+ 	/// Runs the showcase demo
+ 	/// </summary>
+ 	public static async Task RunAsync()
+ 	{
+ 		var consoleProvider = new SpectreConsoleProvider();
+ 		var app = UIApplication.CreateBuilder(consoleProvider)
+ 			.UseRootElement(CreateShowcaseUI())
+ 			.Build();
+ 
+ 		Console.WriteLine("Starting TUI Showcase Demo. Displaying all visual features...");
+ 		await app.RunAsync();
+ 		Console.WriteLine("Showcase Demo finished.");
+ 	}
+ 
+ 	private static IUIElement CreateShowcaseUI()
+ 	{
+ 		var mainLayout = new StackPanel
+ 		{
+ 			Orientation = Orientation.Vertical,
+ 			Spacing = 1,
+ 			Padding = Padding.Uniform(1)
+ 		};
+ 
+ 		// Header
+ 		var header = CreateHeader();
+ 
+ 		// Content area with three columns
+ 		var contentArea = CreateContentArea();
+ 
+ 		// Footer
+ 		var footer = CreateFooter();
+ 
+ 		mainLayout.AddChild(header);
+ 		mainLayout.AddChild(contentArea);
+ 		mainLayout.AddChild(footer);
+ 
+ 		return mainLayout;
+ 	}
+ 
+ 	private static IUIElement CreateHeader()
+ 	{
+ 		return new BorderElement
+ 		{
+ 			Title = "TUI Library Showcase",
+ 			TitleAlignment = HorizontalAlignment.Center,
+ 			BorderStyle = BorderStyle.Double,
+ 			Child = new StackPanel
+ 			{
+ 				Orientation = Orientation.Vertical,
+ 				Children = new List<IUIElement>
+ 				{
+ 					new TextElement
+ 					{
+ 						Text = "Complete Visual Features Demonstration",
+ 						HorizontalAlignment = HorizontalAlignment.Center,
+ 						Style = new TextStyle { IsBold = true, Foreground = "yellow" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Text Styles • Borders • Layouts • Alignments • Colors",
+ 						HorizontalAlignment = HorizontalAlignment.Center,
+ 						Style = new TextStyle { Foreground = "gray" }
+ 					}
+ 				}
+ 			}
+ 		};
+ 	}
+ 
+ 	private static IUIElement CreateContentArea()
+ 	{
+ 		var contentLayout = new StackPanel
+ 		{
+ 			Orientation = Orientation.Horizontal,
+ 			Spacing = 2
+ 		};
+ 
+ 		// Left column - Text styles
+ 		var leftColumn = CreateTextStylesColumn();
+ 
+ 		// Middle column - Border styles
+ 		var middleColumn = CreateBorderStylesColumn();
+ 
+ 		// Right column - Alignment and layouts
+ 		var rightColumn = CreateAlignmentColumn();
+ 
+ 		contentLayout.AddChild(leftColumn);
+ 		contentLayout.AddChild(middleColumn);
+ 		contentLayout.AddChild(rightColumn);
+ 
+ 		return contentLayout;
+ 	}
+ 
+ 	private static IUIElement CreateTextStylesColumn()
+ 	{
+ 		var column = new StackPanel
+ 		{
+ 			Orientation = Orientation.Vertical,
+ 			Spacing = 1
+ 		};
+ 
+ 		// Text styles panel
+ 		var textStylesPanel = new BorderElement
+ 		{
+ 			Title = "Text Styles",
+ 			BorderStyle = BorderStyle.Single,
+ 			Child = new StackPanel
+ 			{
+ 				Orientation = Orientation.Vertical,
+ 				Children = new List<IUIElement>
+ 				{
+ 					new TextElement
+ 					{
+ 						Text = "Normal Text",
+ 						Style = new TextStyle { Foreground = "white" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Bold Text",
+ 						Style = new TextStyle { IsBold = true, Foreground = "white" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Italic Text",
+ 						Style = new TextStyle { IsItalic = true, Foreground = "white" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Underlined Text",
+ 						Style = new TextStyle { IsUnderline = true, Foreground = "white" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Bold Italic",
+ 						Style = new TextStyle { IsBold = true, IsItalic = true, Foreground = "cyan" }
+ 					}
+ 				}
+ 			}
+ 		};
+ 
+ 		// Color showcase panel
+ 		var colorPanel = new BorderElement
+ 		{
+ 			Title = "Colors",
+ 			BorderStyle = BorderStyle.Rounded,
+ 			Child = new StackPanel
+ 			{
+ 				Orientation = Orientation.Vertical,
+ 				Children = new List<IUIElement>
+ 				{
+ 					new TextElement
+ 					{
+ 						Text = "Red Text",
+ 						Style = new TextStyle { Foreground = "red" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Green Text",
+ 						Style = new TextStyle { Foreground = "green" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Blue Text",
+ 						Style = new TextStyle { Foreground = "blue" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Yellow on Black",
+ 						Style = new TextStyle { Foreground = "yellow", Background = "black" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "White on Red",
+ 						Style = new TextStyle { Foreground = "white", Background = "red" }
+ 					}
+ 				}
+ 			}
+ 		};
+ 
+ 		column.AddChild(textStylesPanel);
+ 		column.AddChild(colorPanel);
+ 
+ 		return column;
+ 	}
+ 
+ 	private static IUIElement CreateBorderStylesColumn()
+ 	{
+ 		var column = new StackPanel
+ 		{
+ 			Orientation = Orientation.Vertical,
+ 			Spacing = 1
+ 		};
+ 
+ 		// Create examples of each border style
+ 		var borderStyles = new[]
+ 		{
+ 			(BorderStyle.None, "None"),
+ 			(BorderStyle.Single, "Single"),
+ 			(BorderStyle.Double, "Double"),
+ 			(BorderStyle.Rounded, "Rounded"),
+ 			(BorderStyle.Thick, "Thick"),
+ 			(BorderStyle.Ascii, "ASCII")
+ 		};
+ 
+ 		foreach (var (style, name) in borderStyles)
+ 		{
+ 			var borderExample = new BorderElement
+ 			{
+ 				Title = $"{name} Border",
+ 				BorderStyle = style,
+ 				Child = new TextElement
+ 				{
+ 					Text = $"Content with {name.ToLower()} border",
+ 					HorizontalAlignment = HorizontalAlignment.Center,
+ 					Style = new TextStyle { Foreground = "cyan" }
+ 				}
+ 			};
+ 
+ 			column.AddChild(borderExample);
+ 		}
+ 
+ 		return column;
+ 	}
+ 
+ 	private static IUIElement CreateAlignmentColumn()
+ 	{
+ 		var column = new StackPanel
+ 		{
+ 			Orientation = Orientation.Vertical,
+ 			Spacing = 1
+ 		};
+ 
+ 		// Horizontal alignment demo
+ 		var horizontalAlignmentPanel = new BorderElement
+ 		{
+ 			Title = "Horizontal Alignment",
+ 			BorderStyle = BorderStyle.Single,
+ 			Child = new StackPanel
+ 			{
+ 				Orientation = Orientation.Vertical,
+ 				Children = new List<IUIElement>
+ 				{
+ 					new TextElement
+ 					{
+ 						Text = "Left Aligned",
+ 						HorizontalAlignment = HorizontalAlignment.Left,
+ 						Style = new TextStyle { Foreground = "green" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Center Aligned",
+ 						HorizontalAlignment = HorizontalAlignment.Center,
+ 						Style = new TextStyle { Foreground = "yellow" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Right Aligned",
+ 						HorizontalAlignment = HorizontalAlignment.Right,
+ 						Style = new TextStyle { Foreground = "red" }
+ 					}
+ 				}
+ 			}
+ 		};
+ 
+ 		// Layout demo
+ 		var layoutPanel = new BorderElement
+ 		{
+ 			Title = "Layout Demo",
+ 			BorderStyle = BorderStyle.Thick,
+ 			Child = new StackPanel
+ 			{
+ 				Orientation = Orientation.Vertical,
+ 				Spacing = 1,
+ 				Children = new List<IUIElement>
+ 				{
+ 					new TextElement
+ 					{
+ 						Text = "Vertical Layout:",
+ 						Style = new TextStyle { IsBold = true, Foreground = "white" }
+ 					},
+ 					new StackPanel
+ 					{
+ 						Orientation = Orientation.Horizontal,
+ 						Spacing = 1,
+ 						Children = new List<IUIElement>
+ 						{
+ 							new TextElement
+ 							{
+ 								Text = "[A]",
+ 								Style = new TextStyle { Background = "blue", Foreground = "white" }
+ 							},
+ 							new TextElement
+ 							{
+ 								Text = "[B]",
+ 								Style = new TextStyle { Background = "red", Foreground = "white" }
+ 							},
+ 							new TextElement
+ 							{
+ 								Text = "[C]",
+ 								Style = new TextStyle { Background = "green", Foreground = "white" }
+ 							}
+ 						}
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Horizontal Layout ↑",
+ 						Style = new TextStyle { Foreground = "gray" }
+ 					}
+ 				}
+ 			}
+ 		};
+ 
+ 		// Padding demo
+ 		var paddingPanel = new BorderElement
+ 		{
+ 			Title = "Padding Demo",
+ 			BorderStyle = BorderStyle.Double,
+ 			Child = new BorderElement
+ 			{
+ 				BorderStyle = BorderStyle.Single,
+ 				Child = new TextElement
+ 				{
+ 					Text = "Nested with padding",
+ 					HorizontalAlignment = HorizontalAlignment.Center,
+ 					Style = new TextStyle { Foreground = "magenta" }
+ 				},
+ 				Padding = Padding.Uniform(2)
+ 			}
+ 		};
+ 
+ 		column.AddChild(horizontalAlignmentPanel);
+ 		column.AddChild(layoutPanel);
+ 		column.AddChild(paddingPanel);
+ 
+ 		return column;
+ 	}
+ 
+ 	private static IUIElement CreateFooter()
+ 	{
+ 		return new BorderElement
+ 		{
+ 			Title = "System Information",
+ 			BorderStyle = BorderStyle.Ascii,
+ 			Child = new StackPanel
+ 			{
+ 				Orientation = Orientation.Horizontal,
+ 				Spacing = 3,
+ 				Children = new List<IUIElement>
+ 				{
+ 					new TextElement
+ 					{
+ 						Text = $"Platform: {Environment.OSVersion.Platform}",
+ 						Style = new TextStyle { Foreground = "cyan" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = $"Framework: {Environment.Version}",
+ 						Style = new TextStyle { Foreground = "yellow" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = $"Time: {DateTime.Now:yyyy-MM-dd HH:mm:ss}",
+ 						Style = new TextStyle { Foreground = "green" }
+ 					},
+ 					new TextElement
+ 					{
+ 						Text = "Press ESC to exit",
+ 						Style = new TextStyle { Foreground = "red", IsBold = true }
+ 					}
+ 				}
+ 			}
+ 		};
+ 	}
+ } 
```

---

Now let me create comprehensive tests for the TUI library. First, I'll need to understand what testing infrastructure is already in place:

---

Read file: TUI.Test/SampleTests.cs

---

I need to update the test project to reference the TUI.Core project and create comprehensive tests. Let me first update the project file:

---

```diff
  <Project Sdk="ktsu.Sdk.Test">
+ 
+   <ItemGroup>
+     <ProjectReference Include="../TUI.Core/TUI.Core.csproj" />
+   </ItemGroup>
+ 
+   <ItemGroup>
+     <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0" />
+     <PackageReference Include="MSTest.TestAdapter" Version="3.1.1" />
+     <PackageReference Include="MSTest.TestFramework" Version="3.1.1" />
+     <PackageReference Include="Moq" Version="4.20.69" />
+   </ItemGroup>
+ 
  </Project>
  
```

---

Now let me replace the sample tests with comprehensive TUI tests:

---

```diff
  // All rights reserved.
  // Licensed under the MIT license.
+ 
+ using ktsu.TUI.Core.Contracts;
+ using ktsu.TUI.Core.Elements.Primitives;
+ using ktsu.TUI.Core.Models;
+ using Moq;
  
  namespace ktsu.TUI.Test;
  
+ /// <summary>
+ /// Tests for basic TUI elements functionality
+ /// </summary>
  [TestClass]
- public class SampleTests
- {
+ public class UIElementTests
+ {
+ 	/// <summary>
+ 	/// Tests that TextElement properly sets and gets text property
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void TextElement_SetText_UpdatesTextProperty()
+ 	{
+ 		// Arrange
+ 		var textElement = new TextElement();
+ 		var expectedText = "Hello World";
+ 
+ 		// Act
+ 		textElement.Text = expectedText;
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedText, textElement.Text);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that TextElement invalidates when text changes
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void TextElement_ChangeText_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var textElement = new TextElement("Initial text");
+ 		bool invalidated = false;
+ 		textElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		textElement.Text = "New text";
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that TextElement doesn't invalidate when setting same text
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void TextElement_SetSameText_DoesNotInvalidate()
+ 	{
+ 		// Arrange
+ 		var initialText = "Same text";
+ 		var textElement = new TextElement(initialText);
+ 		bool invalidated = false;
+ 		textElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		textElement.Text = initialText;
+ 
+ 		// Assert
+ 		Assert.IsFalse(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that TextElement handles null text gracefully
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void TextElement_SetNullText_SetsEmptyString()
+ 	{
+ 		// Arrange
+ 		var textElement = new TextElement();
+ 
+ 		// Act
+ 		textElement.Text = null!;
+ 
+ 		// Assert
+ 		Assert.AreEqual(string.Empty, textElement.Text);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that TextElement initializes with correct default values
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void TextElement_DefaultConstructor_InitializesCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var textElement = new TextElement();
+ 
+ 		// Assert
+ 		Assert.AreEqual(string.Empty, textElement.Text);
+ 		Assert.AreEqual(HorizontalAlignment.Left, textElement.HorizontalAlignment);
+ 		Assert.AreEqual(VerticalAlignment.Top, textElement.VerticalAlignment);
+ 		Assert.IsFalse(textElement.WordWrap);
+ 		Assert.IsTrue(textElement.IsVisible);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that TextElement constructor with text parameter works correctly
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void TextElement_ConstructorWithText_SetsTextCorrectly()
+ 	{
+ 		// Arrange
+ 		var expectedText = "Constructor text";
+ 
+ 		// Act
+ 		var textElement = new TextElement(expectedText);
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedText, textElement.Text);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that TextElement constructor with text and style works correctly
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void TextElement_ConstructorWithTextAndStyle_SetsPropertiesCorrectly()
+ 	{
+ 		// Arrange
+ 		var expectedText = "Styled text";
+ 		var expectedStyle = new TextStyle { IsBold = true, Foreground = "red" };
+ 
+ 		// Act
+ 		var textElement = new TextElement(expectedText, expectedStyle);
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedText, textElement.Text);
+ 		Assert.AreEqual(expectedStyle.IsBold, textElement.Style.IsBold);
+ 		Assert.AreEqual(expectedStyle.Foreground, textElement.Style.Foreground);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that Position property changes trigger invalidation
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void UIElement_ChangePosition_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var textElement = new TextElement();
+ 		bool invalidated = false;
+ 		textElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		textElement.Position = new Position(10, 20);
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 		Assert.AreEqual(10, textElement.Position.X);
+ 		Assert.AreEqual(20, textElement.Position.Y);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that Dimensions property changes trigger invalidation
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void UIElement_ChangeDimensions_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var textElement = new TextElement();
+ 		bool invalidated = false;
+ 		textElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		textElement.Dimensions = new Dimensions(100, 50);
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 		Assert.AreEqual(100, textElement.Dimensions.Width);
+ 		Assert.AreEqual(50, textElement.Dimensions.Height);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that Visibility property changes trigger invalidation
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void UIElement_ChangeVisibility_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var textElement = new TextElement();
+ 		bool invalidated = false;
+ 		textElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		textElement.IsVisible = false;
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 		Assert.IsFalse(textElement.IsVisible);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that Render doesn't execute when element is not visible
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void UIElement_RenderWhenNotVisible_DoesNotCallOnRender()
+ 	{
+ 		// Arrange
+ 		var mockProvider = new Mock<IConsoleProvider>();
+ 		var textElement = new TextElement("Test text")
+ 		{
+ 			IsVisible = false
+ 		};
+ 
+ 		// Act
+ 		textElement.Render(mockProvider.Object);
+ 
+ 		// Assert
+ 		mockProvider.VerifyNoOtherCalls();
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that HandleInput returns false by default
+ 	/// </summary>
  	[TestMethod]
- 	public void Echo_ReturnsProvidedValue()
+ 	public void UIElement_HandleInput_ReturnsFalseByDefault()
  	{
  		// Arrange
- 		var expectedValue = 42;
+ 		var textElement = new TextElement();
+ 		var input = new InputResult { Key = "Enter", Modifiers = InputModifiers.None };
  
  		// Act
- 		var result = Sample.Echo(expectedValue);
+ 		var result = textElement.HandleInput(input);
  
  		// Assert
- 		Assert.AreEqual(expectedValue, result);
+ 		Assert.IsFalse(result);
  	}
  
+ 	/// <summary>
+ 	/// Tests that Padding property is properly set and retrieved
+ 	/// </summary>
  	[TestMethod]
- 	public void Echo_WithString_ReturnsProvidedString()
+ 	public void UIElement_SetPadding_UpdatesPaddingProperty()
  	{
  		// Arrange
- 		var expectedValue = "Hello World";
+ 		var textElement = new TextElement();
+ 		var expectedPadding = new Padding(1, 2, 3, 4);
  
  		// Act
- 		var result = Sample.Echo(expectedValue);
+ 		textElement.Padding = expectedPadding;
  
  		// Assert
- 		Assert.AreEqual(expectedValue, result);
+ 		Assert.AreEqual(expectedPadding, textElement.Padding);
  	}
  }
```

---

Now let me create tests for the Border element:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.TUI.Core.Contracts;
+ using ktsu.TUI.Core.Elements.Primitives;
+ using ktsu.TUI.Core.Models;
+ using Moq;
+ 
+ namespace ktsu.TUI.Test;
+ 
+ /// <summary>
+ /// Tests for BorderElement functionality
+ /// </summary>
+ [TestClass]
+ public class BorderElementTests
+ {
+ 	/// <summary>
+ 	/// Tests that BorderElement initializes with correct default values
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_DefaultConstructor_InitializesCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var borderElement = new BorderElement();
+ 
+ 		// Assert
+ 		Assert.AreEqual(BorderStyle.Single, borderElement.BorderStyle);
+ 		Assert.AreEqual(string.Empty, borderElement.Title);
+ 		Assert.AreEqual(HorizontalAlignment.Left, borderElement.TitleAlignment);
+ 		Assert.IsNull(borderElement.Child);
+ 		Assert.IsTrue(borderElement.IsVisible);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement properly sets and gets title property
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_SetTitle_UpdatesTitleProperty()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement();
+ 		var expectedTitle = "Test Title";
+ 
+ 		// Act
+ 		borderElement.Title = expectedTitle;
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedTitle, borderElement.Title);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement invalidates when title changes
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_ChangeTitle_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement { Title = "Initial Title" };
+ 		bool invalidated = false;
+ 		borderElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		borderElement.Title = "New Title";
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement doesn't invalidate when setting same title
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_SetSameTitle_DoesNotInvalidate()
+ 	{
+ 		// Arrange
+ 		var initialTitle = "Same Title";
+ 		var borderElement = new BorderElement { Title = initialTitle };
+ 		bool invalidated = false;
+ 		borderElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		borderElement.Title = initialTitle;
+ 
+ 		// Assert
+ 		Assert.IsFalse(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement properly sets border style
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_SetBorderStyle_UpdatesBorderStyleProperty()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement();
+ 		var expectedStyle = BorderStyle.Double;
+ 
+ 		// Act
+ 		borderElement.BorderStyle = expectedStyle;
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedStyle, borderElement.BorderStyle);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement invalidates when border style changes
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_ChangeBorderStyle_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement { BorderStyle = BorderStyle.Single };
+ 		bool invalidated = false;
+ 		borderElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		borderElement.BorderStyle = BorderStyle.Double;
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement properly sets title alignment
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_SetTitleAlignment_UpdatesTitleAlignmentProperty()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement();
+ 		var expectedAlignment = HorizontalAlignment.Center;
+ 
+ 		// Act
+ 		borderElement.TitleAlignment = expectedAlignment;
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedAlignment, borderElement.TitleAlignment);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement invalidates when title alignment changes
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_ChangeTitleAlignment_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement { TitleAlignment = HorizontalAlignment.Left };
+ 		bool invalidated = false;
+ 		borderElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		borderElement.TitleAlignment = HorizontalAlignment.Right;
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement properly sets child element
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_SetChild_UpdatesChildProperty()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement();
+ 		var childElement = new TextElement("Child content");
+ 
+ 		// Act
+ 		borderElement.Child = childElement;
+ 
+ 		// Assert
+ 		Assert.AreEqual(childElement, borderElement.Child);
+ 		Assert.AreEqual(borderElement, childElement.Parent);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement invalidates when child changes
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_ChangeChild_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement { Child = new TextElement("Initial child") };
+ 		bool invalidated = false;
+ 		borderElement.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		borderElement.Child = new TextElement("New child");
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement handles null child gracefully
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_SetNullChild_HandlesGracefully()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement();
+ 		var initialChild = new TextElement("Initial child");
+ 		borderElement.Child = initialChild;
+ 
+ 		// Act
+ 		borderElement.Child = null;
+ 
+ 		// Assert
+ 		Assert.IsNull(borderElement.Child);
+ 		Assert.IsNull(initialChild.Parent);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests all border style enum values
+ 	/// </summary>
+ 	[TestMethod]
+ 	[DataRow(BorderStyle.None)]
+ 	[DataRow(BorderStyle.Single)]
+ 	[DataRow(BorderStyle.Double)]
+ 	[DataRow(BorderStyle.Rounded)]
+ 	[DataRow(BorderStyle.Thick)]
+ 	[DataRow(BorderStyle.Ascii)]
+ 	public void BorderElement_SetBorderStyleValues_AcceptsAllValidValues(BorderStyle borderStyle)
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement();
+ 
+ 		// Act
+ 		borderElement.BorderStyle = borderStyle;
+ 
+ 		// Assert
+ 		Assert.AreEqual(borderStyle, borderElement.BorderStyle);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement constructor with child sets properties correctly
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_ConstructorWithChild_SetsPropertiesCorrectly()
+ 	{
+ 		// Arrange
+ 		var childElement = new TextElement("Constructor child");
+ 
+ 		// Act
+ 		var borderElement = new BorderElement { Child = childElement };
+ 
+ 		// Assert
+ 		Assert.AreEqual(childElement, borderElement.Child);
+ 		Assert.AreEqual(borderElement, childElement.Parent);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement with title renders correctly when not visible
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_RenderWhenNotVisible_DoesNotCallOnRender()
+ 	{
+ 		// Arrange
+ 		var mockProvider = new Mock<IConsoleProvider>();
+ 		var borderElement = new BorderElement 
+ 		{ 
+ 			Title = "Test Border",
+ 			Child = new TextElement("Test content"),
+ 			IsVisible = false
+ 		};
+ 
+ 		// Act
+ 		borderElement.Render(mockProvider.Object);
+ 
+ 		// Assert
+ 		mockProvider.VerifyNoOtherCalls();
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement handles input by delegating to child
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_HandleInput_DelegatesToChild()
+ 	{
+ 		// Arrange
+ 		var mockChild = new Mock<IUIElement>();
+ 		mockChild.Setup(c => c.HandleInput(It.IsAny<InputResult>())).Returns(true);
+ 		var borderElement = new BorderElement { Child = mockChild.Object };
+ 		var input = new InputResult { Key = "Enter", Modifiers = InputModifiers.None };
+ 
+ 		// Act
+ 		var result = borderElement.HandleInput(input);
+ 
+ 		// Assert
+ 		Assert.IsTrue(result);
+ 		mockChild.Verify(c => c.HandleInput(input), Times.Once);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that BorderElement with no child returns false for input
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void BorderElement_HandleInputWithNoChild_ReturnsFalse()
+ 	{
+ 		// Arrange
+ 		var borderElement = new BorderElement();
+ 		var input = new InputResult { Key = "Enter", Modifiers = InputModifiers.None };
+ 
+ 		// Act
+ 		var result = borderElement.HandleInput(input);
+ 
+ 		// Assert
+ 		Assert.IsFalse(result);
+ 	}
+ } 
```

---

Now let me create tests for the StackPanel layout component:

---



---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.TUI.Core.Contracts;
+ using ktsu.TUI.Core.Elements.Layouts;
+ using ktsu.TUI.Core.Elements.Primitives;
+ using ktsu.TUI.Core.Models;
+ using Moq;
+ 
+ namespace ktsu.TUI.Test;
+ 
+ /// <summary>
+ /// Tests for StackPanel layout functionality
+ /// </summary>
+ [TestClass]
+ public class StackPanelTests
+ {
+ 	/// <summary>
+ 	/// Tests that StackPanel initializes with correct default values
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_DefaultConstructor_InitializesCorrectly()
+ 	{
+ 		// Arrange & Act
+ 		var stackPanel = new StackPanel();
+ 
+ 		// Assert
+ 		Assert.AreEqual(Orientation.Vertical, stackPanel.Orientation);
+ 		Assert.AreEqual(0, stackPanel.Spacing);
+ 		Assert.IsNotNull(stackPanel.Children);
+ 		Assert.AreEqual(0, stackPanel.Children.Count);
+ 		Assert.IsTrue(stackPanel.IsVisible);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel properly sets orientation
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_SetOrientation_UpdatesOrientationProperty()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var expectedOrientation = Orientation.Horizontal;
+ 
+ 		// Act
+ 		stackPanel.Orientation = expectedOrientation;
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedOrientation, stackPanel.Orientation);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel invalidates when orientation changes
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_ChangeOrientation_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel { Orientation = Orientation.Vertical };
+ 		bool invalidated = false;
+ 		stackPanel.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		stackPanel.Orientation = Orientation.Horizontal;
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel properly sets spacing
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_SetSpacing_UpdatesSpacingProperty()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var expectedSpacing = 5;
+ 
+ 		// Act
+ 		stackPanel.Spacing = expectedSpacing;
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedSpacing, stackPanel.Spacing);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel invalidates when spacing changes
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_ChangeSpacing_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel { Spacing = 0 };
+ 		bool invalidated = false;
+ 		stackPanel.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		stackPanel.Spacing = 3;
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel can add child elements
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_AddChild_AddsChildToCollection()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var child = new TextElement("Test child");
+ 
+ 		// Act
+ 		stackPanel.AddChild(child);
+ 
+ 		// Assert
+ 		Assert.AreEqual(1, stackPanel.Children.Count);
+ 		Assert.AreEqual(child, stackPanel.Children[0]);
+ 		Assert.AreEqual(stackPanel, child.Parent);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel invalidates when child is added
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_AddChild_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		bool invalidated = false;
+ 		stackPanel.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		stackPanel.AddChild(new TextElement("Test child"));
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel can remove child elements
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_RemoveChild_RemovesChildFromCollection()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var child = new TextElement("Test child");
+ 		stackPanel.AddChild(child);
+ 
+ 		// Act
+ 		var result = stackPanel.RemoveChild(child);
+ 
+ 		// Assert
+ 		Assert.IsTrue(result);
+ 		Assert.AreEqual(0, stackPanel.Children.Count);
+ 		Assert.IsNull(child.Parent);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel invalidates when child is removed
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_RemoveChild_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var child = new TextElement("Test child");
+ 		stackPanel.AddChild(child);
+ 		bool invalidated = false;
+ 		stackPanel.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		stackPanel.RemoveChild(child);
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel remove returns false for non-existent child
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_RemoveNonExistentChild_ReturnsFalse()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var child = new TextElement("Test child");
+ 
+ 		// Act
+ 		var result = stackPanel.RemoveChild(child);
+ 
+ 		// Assert
+ 		Assert.IsFalse(result);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel can clear all children
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_ClearChildren_RemovesAllChildren()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var child1 = new TextElement("Child 1");
+ 		var child2 = new TextElement("Child 2");
+ 		stackPanel.AddChild(child1);
+ 		stackPanel.AddChild(child2);
+ 
+ 		// Act
+ 		stackPanel.ClearChildren();
+ 
+ 		// Assert
+ 		Assert.AreEqual(0, stackPanel.Children.Count);
+ 		Assert.IsNull(child1.Parent);
+ 		Assert.IsNull(child2.Parent);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel invalidates when children are cleared
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_ClearChildren_TriggersInvalidation()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		stackPanel.AddChild(new TextElement("Test child"));
+ 		bool invalidated = false;
+ 		stackPanel.Invalidated += (sender, args) => invalidated = true;
+ 
+ 		// Act
+ 		stackPanel.ClearChildren();
+ 
+ 		// Assert
+ 		Assert.IsTrue(invalidated);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel handles null child gracefully
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_AddNullChild_ThrowsArgumentNullException()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 
+ 		// Act & Assert
+ 		Assert.ThrowsException<ArgumentNullException>(() => stackPanel.AddChild(null!));
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel handles input by checking children
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_HandleInput_ChecksChildren()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var mockChild1 = new Mock<IUIElement>();
+ 		var mockChild2 = new Mock<IUIElement>();
+ 		
+ 		mockChild1.Setup(c => c.HandleInput(It.IsAny<InputResult>())).Returns(false);
+ 		mockChild2.Setup(c => c.HandleInput(It.IsAny<InputResult>())).Returns(true);
+ 		
+ 		stackPanel.AddChild(mockChild1.Object);
+ 		stackPanel.AddChild(mockChild2.Object);
+ 		
+ 		var input = new InputResult { Key = "Enter", Modifiers = InputModifiers.None };
+ 
+ 		// Act
+ 		var result = stackPanel.HandleInput(input);
+ 
+ 		// Assert
+ 		Assert.IsTrue(result);
+ 		mockChild1.Verify(c => c.HandleInput(input), Times.Once);
+ 		mockChild2.Verify(c => c.HandleInput(input), Times.Once);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel returns false when no children handle input
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_HandleInputNoChildrenHandleIt_ReturnsFalse()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var mockChild = new Mock<IUIElement>();
+ 		mockChild.Setup(c => c.HandleInput(It.IsAny<InputResult>())).Returns(false);
+ 		stackPanel.AddChild(mockChild.Object);
+ 		
+ 		var input = new InputResult { Key = "Enter", Modifiers = InputModifiers.None };
+ 
+ 		// Act
+ 		var result = stackPanel.HandleInput(input);
+ 
+ 		// Assert
+ 		Assert.IsFalse(result);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests that StackPanel with no children returns false for input
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void StackPanel_HandleInputWithNoChildren_ReturnsFalse()
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 		var input = new InputResult { Key = "Enter", Modifiers = InputModifiers.None };
+ 
+ 		// Act
+ 		var result = stackPanel.HandleInput(input);
+ 
+ 		// Assert
+ 		Assert.IsFalse(result);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests orientation enum values
+ 	/// </summary>
+ 	[TestMethod]
+ 	[DataRow(Orientation.Vertical)]
+ 	[DataRow(Orientation.Horizontal)]
+ 	public void StackPanel_SetOrientationValues_AcceptsAllValidValues(Orientation orientation)
+ 	{
+ 		// Arrange
+ 		var stackPanel = new StackPanel();
+ 
+ 		// Act
+ 		stackPanel.Orientation = orientation;
+ 
+ 		// Assert
+ 		Assert.AreEqual(orientation, stackPanel.Orientation);
+ 	}
+ }
+ 
```

---





---

